# CPU 스케줄러

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdpjqxb%2FbtrlvBUm1QZ%2FZqsEUUNwT1NeOrm3DTMOw0%2Fimg.png" width="800"> <br>
[프로세스 상태 변화도] <br>
- 생성(new) : 사용자에 의해 프로세스가 생성된 상태
- 준비(ready) : CPU를 할당받을 수 있는 상태, 가장 높은 우선순위를 갖는 프로세스가 다음 순서에 CPU를 할당받음
- 실행(running) : CPU를 할당받아 동작(점유) 중인 상태
- 대기(waiting), 블록(blocked) : 프로세스 실행 중 입출력(I/O)처리 등으로 CPU를 양도하고 처리 완료까지 기다리는 상태, 대기 리스트는 우선순위가 존재하지 않음
- 종료(terminated) : 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태

CPU는 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다.
이때 어떤 프로세스를 다음에 처리할 지 선택하는 알고리즘을 스케줄링 알고리즘이라고 한다. 
스케줄링 알고리즘에는 점유 방식에 의한 구분으로 비선점 스케줄링 방식과 선점 스케줄링 방식이 있다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtpZL1%2FbtrlvBmuqKp%2FymP0PUX6tZIUpqUXKwS351%2Fimg.png" width="800"> <br>
[프로세스 상태] <br>
- 제출(submit) : 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
- 접수(hold) : 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태

## 1. 비선점 스케줄링 <br>
이미 할당받은 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법이다. <br>
프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다. <br>

### 비선점 스케줄링 장점 
-모든 프로세스에 대한 요구를 공정하게 처리할 수 있다. <br>
프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합하다.

### 비선점 스케줄링 단점
중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있다.

### 비선점 스케줄링 알고리즘
FCFS, SJF, HRN, 우선순위(비선점) 등

- 선입선처리 (FCFS : First Come First Service)
  - 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당
  - 가장 간단한 스케줄링 알고리즘으로 구현이 쉬움
  - 대화식 프로세스에 적합하지 않습
  - 공평성은 유지되지만 중요한 작업이 중요하지 않은 작업을 기다리게 되는 경우 발생
- 최소 작업 우선 (SJF : Shortest Job First)
  - 실행 시간이 짧은 프로세스에 먼저 CPU 할당
  - 실행 시간이 짧은 작업을 먼저 실행하기 때문에 평균 대기시간이 다른 알고리즘에 비해 짧음
  - 짧은 작업들이 계속 생기는 경우 작업 시간이 긴 프로세스가 너무 오래 기다리는 현상이 발생
  - 짧은 작업에 최우선으로 CPU를 할당하기 때문에 공평하지 않음
- 최고 응답률 우선 (HRN : Hightest Response-ratio Next)
  - 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 기법
  - 대기시간과 실행 시간을 이용
  - 우선순위 계산 결과값이 높은 것부터 우선순위를 부여, 대기시간이 긴 프로세스일 경우 계산 결과값이 높게 나옴
- 우선순위(비선점)
  - 프로세스마다 우선순위를 부여하여 높은 우선순위를 가진 프로세스에게 먼저 자원을 할당하는 방법
  - 비선점 우선순위 스케줄링은 실행중인 것과 무관하게 우선순위가 높으면 큐의 가장 앞에 위치
  - 각 프로세스의 상대적 중요도를 명시, 실시간 시스템에 유리
  - 높은 우선순위 프로세스가 계속 들어올 경우 우선순위가 낮은 프로세스가 너무 오래 기다리는 현상이 발생

## 2. 선점 스케줄링 <br>
하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법이다. <br>
선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요하다. <br>

### 선점 스케줄링 장점 <br> 
우선순위가 높은 프로세스를 빠르게 처리할 수 있다.<br>
주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용된다.

### 선점 스케줄링 단점 <br> 
우선순위가 높은 프로세스들이 계속 들어오는 경우 오버헤드(Overhead)를 초래한다. 

### 선점 스케줄링 알고리즘
RR, SRT, MLQ, MLFQ, 우선순위(선점) 등

- 라운드 로빈 (RR : Round Robin)
  - FCFS를 선점 형태로 변형한 기법
  - 현대적인 CPU 스케줄링 방식으로 프로세스가 할당된 시간 내에 완료하지 못한다면, 준비 큐 리스트의 가장 뒤로 보내지고 CPU는 대기 중인 다음 프로세스로 넘어감
  - 모든 프로세스가 공정하게 시간을 할당
  - 프로세스 최악의 응답시간을 아는데 유리
  - 하드웨어 타이머가 필요
  - 작업 시간을 너무 짧게한 경우 오버헤드가 발생
- 최소 잔류 시간 우선 (SRT : Shortest Remaining Time)
  - SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식
  - 가장 짧은 실행 시간을 요구하는 프로세스에 CPU 할당
  - SJF 알고리즘을 선점 형태로 변형한 기법
  - 실행 중인 프로세스의 남은 시간과 준비상태 큐에 도착한 프로세스의 실행 시간 비교
- 다단계 큐 (MLQ : Multi Level Queue)
  - 준비 상태 큐를 여러 종류별, 단계별로 분할해두고 자신만의 독자적인 스케줄링 구현이 가능
  - 각 큐는 절대적인 우선순위를 가지며 우선순위가 높은 큐가 모두 비어있기 전에는 낮은 우선순위 큐에 있는 프로세스를 실행할 수 없음
  - 응답속도가 빠름
  - 여러 준비 큐와 스케줄링 알고리즘을 사용하기 때문에 추가 오버헤드가 발생
  - 우선순위가 낮은 큐의 프로세스가 오래 기다리는 현상이 발생
- 다단계 멀티 큐 (MLFQ : Multi Level Feedback Queue)
  - 특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계큐 기법을 이동할 수 있도록 개선한 기법
- 우선순위(선점)
  - 하나의 프로세스가 CPU를 차지하고 있어도 우선순위가 높은 다른 프로세스가 대기하는 경우 현재 프로세스를 중단 시키고 우선순위가 높은 프로세스에게 CPU를 할당하는 스케줄링 방식
  - 응답속도가 빠름
  - 처리 시간을 예측하기 힘듬
  - 우선순위 프로세스들이 계속해서 들어오는 경우 오버헤드가 발생

> 참고사이트 : 
> - https://qazyj.tistory.com/322
> - https://sangchul.kr/99
> - https://velog.io/@inhalin/knou-os-03