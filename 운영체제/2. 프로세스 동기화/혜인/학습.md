# 프로세스 동기화

독립적인(Independent) Process의 경우, 다른 프로세스의 실행에 영향을 주거나 받을 수 없는 구조로 이루어져 있다. <br>
왜냐하면, 프로세스는 실행될 때 고유의 메모리 영역을 할당 받게 되어지므로 서로의 영역에 침범 할 수가 없다. <br>
하지만, Process들 간에서도 IPC(Inter-Process-Communication) 즉, Process들 간의 통신을 통해서 사용하는 변수 혹은 메모리 영역을 공유할 수가 있다. <br>
또한, 여러 Process들간의 공유할 메모리 영역을 특정함수(FileMapping()) 를 이용해서 CPU에게 요청할 수 있다. <br>
하지만 여러 Process들이 사용하는 데이터 혹은 메모리 영역을 공유하게 되면 큰 문제가 하나 발생할 수 있다. <br>
바로, 동기화 문제이다. 동기화라는 것은, 공유 자원에 대한 여러 Process 혹은 Thread의 동시 간섭을 막는 것을 의미한다. 

## Critical Section (크리티컬 섹션 : 임계 구역)

크리티컬 섹션을 말 그대로 해석을 해보면 "임계 구역" 이라는 의미를 가지고 있다.
즉 ! 변수 혹은 메모리가 여러 Process 혹은 Thread에 의해서 공유되고 있어서, 동기화가 필요한 그 영역을 Critical Section 이라고 한다. 

## User Mode & Kernel Mode
운영체제에서는 사용자 인터페이스에 대한 편리성과 안정성을 위해서 CPU를 크게 User-Mode와 Kernel-Mode 2가지 모드로 특정 역할들을 수행하게 된다. 지금부터는 User-Mode와 Kernel Mode에 대해서 구체적으로 알아보도록 하자.

1. User - Mode
UserMode라는 것은 사용자가 응용프로그램들을 사용하기 위해 접근하는 영역이 User Mode이다. 
즉 ! 사용자가 프로그램을 사용할 때, 접근할 수 있는 영역에 제한을 두고, 프로그램 내부에 있는 자원들에게는 함부로 접근할 수 없도록 하는 Mode를 의미한다. 보통 우리는 UserMode에서 Process를 실행할 수도 있고, Code를 작성하는 등과 같은 행위를 할 수 있다.
 
2. Kernel - Mode
KernelMode라는 것은 모든 System Memory와 모든 명령어들에 접근이 가능한 실행모드를 말한다.
즉, OS(운영체제)의 핵심 부분이라고 말할 수 있다. Kernel에서는 CPU Scheduling(CPU 스케쥴링), 
Memory Management(메모리 관리), IO Management(입출력 관리), File System Management(파일 시스템 관리) 등의 일을 한다.

## User Mode 와 Kernel Mode의 관계 
Process는 UserMode에서 실행되다가 Interrupt(장애 및 에러)에 걸리게 되거나, Kernel에게 특별한 요구사항이 필요할 때, System-Call을 이용해서 Kernel Mode를 호출할 수 있다. 호출을 하게 되면, Kernel Mode에서는 사용자의 요구사항 혹은 Interrupt에 대해서 해결해주고 다시 UserMode에게 return 해주는 방식이다.

## 공유자원에 대한 동기화를 맞추는 기법으로는 크리티컬 섹션 / 뮤텍스 / 세마포어 / 모니터가 있다.

## 크리티컬 섹션(Critical Section)
공유되고 있는 영역 자체를 Critical Section 이라고도 하지만, 이 영역에 대한 동기화를 맞추는 기법 중에 하나이기도 하다. <br>
크리티컬 섹션은 "User Mode에서 공유 자원에 대한 동기화를 설정해 주기 위한 기법" 이다. <br>Kernel Mode까지 접근하지 않아도 되기 때문에, Kernel Mode에서 동기화를 하는 것에 비해 가볍고 빠르다. 또한, OS의 객체를 사용하는 것이 아닌, 프로세스의 메모리 공간에 정의되어 있는 변수를 이용하여 동기화를 맞추는 기법이라서, "하나의 프로세스 내의 Thread들에 대한 동기화를 맞춰줄 수는 있지만, 서로 다른 여러개의 프로세스간의 동기화를 맞춰줄 수는 없다." 그리고 공유 자원에 대해서는 '1개'의 Thread만이 접근 가능하도록 만들어 준다.

- User Mode에서 사용되는 동기화 기법이다.
- User Mode에서 사용되므로, Kernel 객체에 비해서 훨씬 가벼고 빠르다.
- 하나의 Process내에 있는 Thread들 간의 동기화만 맞춰줄 수 있으며, 1개의 Thread만 접근이 가능하게 만들어 준다.
- 뮤텍스 와의 가장 큰 차이점은, Thread간의 동기화만 맞춰줄 수 있고 Process간의 동기화를 맞춰줄 수 없다는 것 이다.

## 뮤텍스 (Mutex : Mutual Exclusion 상호 배제)
뮤텍스는 "Kernel Mode에서 공유자원에 대한 동기화를 설정해 주기 위한 기법" 중의 하나이다. 크리티컬 섹션과 외적인 기능은 동일하지만, OS 내부의 Kernel에 접근하여 Kernel객체를 이용해서 OS가 제공하는 특정 함수로 사용할 수 있다.
Kernel Mode까지 접근해야 하므로 크리티컬 섹션에 비해서 느리다. 하지만, 다수의 Thread는 물론, 서로 다른 Process간의 동기화 작업이 가능하다. 뮤텍스 또한, 공유 자원에 대해서 '1개'의 Thread혹은 Process만 접근 가능하도록 만들어 준다.
이를 위해서 일반적으로 Signal, Non-Signal 2개의 비트로 공유자원에 대한 사용 여부를 표시하게 된다.

- Kernel Mode에서 사용되는 동기화 기법이다.
- Kernel Mode에서 사용되므로, User Mode에서 사용되는 방식에 비해서 느리고 무겁다.
- 하나의 Process내에 있는 Thread들 간의 동기화를 맞춰주는 것 뿐만 아니라, 여러 개의 Process들 간의 동기화를 맞춰줄 수
   있으며, 1개의 Thread만이 접근이 가능하게 만들어 준다.
- 크리티컬 섹션과의 가장 큰 차이점은, Process간의 동기화를 맞춰줄 수 있다는 것이다.
- 세마포어와의 가장 큰 차이점은, 공유 자원에 접근할 수 있는 Process or Thread를 1개만 접근이 가능하게 만들어 준다.
- 모니터와의 공통점은 공유 자원에 1개의 Thread만이 접근 가능하게 한다는 것이다.
- 모니터와의 차이점은 뮤텍스는 Process간의 동기화도 맞춰줄 수 있지만, 모니터는 Thread간의 동기화만 맞춰줄 수 있다.
 
## 세마포어 (Semaphore)
세마포어는 뮤텍스와 마찬가지로 "Kernel Mode에서 공유자원에 대한 동기화를 설정해 주기 위한 기법" 중의 하나이다. 하지만 세마포어는 공유자원에 접근할 수 있는 Process 혹은 Thread의 갯수를 Counting할 수 있다. 따라서, 정해진 갯수만큼의 Thread들이 동시에 동기화되는 것을 가능하게 한다.
Mutex가 Signal - NonSignal을 통해서 공유자원에 대한 동기화를 관리하였다면, Semaphore는 몇 개의 Thread가 공유 자원에 진입했는지에 대한 함수와 더 이상 진입이 가능한지 안한지를 나타내는 함수 2개로 동기화를 맞추게 된다.
세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다. 왜냐하면, 세마포어에서 Counting의 수가 1이라면, 이는 뮤텍스와 동일한 역할이지만, 그게 아니라면 뮤텍스는 할 수 없는 일을 하게 되기 때문이다.

- Kernel Mode에서 사용되는 동기화 기법이다.
- Kernel Mode에서 사용되므로, User Mode에서 사용되는 방식에 비해서 느리고 무겁다.
- 하나의 Process내에 있는 Thread들 간의 동기화를 맞춰주는 것 뿐만 아니라, 여러 개의 Process들 간의 동기화를 맞춰줄 수 있으며, Counting 한 갯수 만큼의 Thread가 공유자원에 접근이 가능하게 만들어 준다.
- 뮤텍스와의 가장 큰 차이점은, 공유 자원에 접근할 수 있는 갯수가 여러개가 가능하다는 것이다.
- 모니터와의 차이점은 여러 개의 Process 혹은 Thread가 임계 영역에 접근 가능하게 한다는 것이다.
 
## 모니터 (Monitor)
모니터 또한 동기화를 맞추는 기법 중에 하나이다. 뮤텍스와 세마포어가 어셈블리어에 적합한 도구였다면, 모니터는 이보다 더 고급 언어의 동기화 기법이라고 볼 수 있다. 특히 "자바 프로그램"에서 이 동기화 기법을 주로 사용한다.
모니터에서는 "베타동기" 와 "조건동기" 라고 불리는 2개의 Queue를 사용하게 된다. 베타동기 Queue는 "하나의 Thread만이 공유 자원에 접근할 수 있게 관리해주는 Queue" 이고, 다른 Thread가 공유 자원을 이미 사용 중이라면 접근한 Thread들을 대기시키는 역할을 한다. 조건동기 Queue는 하나의 Thread가 공유자원을 모두 사용하고 나오게 되면, 그 다음 Thread가 공유 자원에 접근할 수 있도록 관리해주는 Queue이다.
모니터는 하나의 프로세스 내에서 여러 개의 Thread들에 대한 동기화만 맞춰줄 수 있다. 또한, 라이브러리 그 자체에서 제공되는 기법이라서 가볍고 빠르다.

- 고급 수준의 언어에서 사용되는 동기화 기법이다.
- Library 자체에서 제공되는 기법이라서 Kernel Mode에 의해서 제공되는 기법들에 비해 빠르고 가볍다.
- 임계 영역에 1개의 Thread만이 접근 가능하게 만들어 준다.
- 뮤텍스와의 차이점은 뮤텍스는 Process 간의 동기화도 맞춰줄 수 있지만, 모니터는 Thread들 간의 동기화만 맞춰줄 수 있다.
- 세마포어와의 차이점은 세마포어의 경우 실제로 Counting 변수를 사용자가 매번 직접 지정해 줘야 하는 번거로움이 존재하지만, 모니터는 이러한 기능들이 캡슐화 되어 있어서 제공되어진 함수를 통해서 편하게 동기화가 가능하다.

> 참고사이트 : 
> - https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-8.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1
> - https://yabmoons.tistory.com/661