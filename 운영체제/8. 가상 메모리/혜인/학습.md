# 가상 메모리

가상메모리는 프로세스 전체가 메모리 내에 올라오지 않더라고 실행이 가능하도록 하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

### 가상 메모리 개발 배경
실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었다. 또한, 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와 페이지 교체 등의 성능 이슈가 발생하게 된다. 또한, 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서, 불필요하게 전체의 프로그램이 메모리에 올라와 있어야 하는 게 아니라는 것을 알 수 있다.

프로그램의 일부분만 메모리에 올릴 수 있다면...
- 물리 메모리 크기에 제약받지 않게 된다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 응답시간은 유지되고, CPU 이용률과 처리율은 높아진다.
- swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.

### 가상 메모리의 역할
가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것이라 정리할 수 있다. 이로써 작은 메모리를 가지고도 얼마든지 큰 가상 메모리 공간을 프로그래머에게 제공할 수 있다.

- 가상 주소 공간
  - 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현한 공간이다. 프로세스가 요구하는 메모리 공간을 가상 메모리에서 제공함으로써 현재 직접적으로 필요치 않은 메모리 공간은 실제 메모리에 올리지 않는 것으로 물리 메모리를 정햑할 수 있다.
  - 예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB가 요구되었다며 하자. 하지만 실행까지의 필요한 메모리 공간(Heap 영역, Stack 영역, 코드, 데이터)의 합이 40KB라면, 실제 메모리에는 40KB만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리 메모리에 요구한다고 이해할 수 있다.
- 프로세스간의 페이지 공유
  - 가상메모리는 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 한다. 각 프로세스들은 공유 라이브러리를 자신의 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가 있는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다.
  - 가상메모리는 프로세스들이 메모리를 공유하는 것을 가능하게 하고, 프로세스들은 공유 메모리로 통해 통신할 수 있다. 이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.
  - 가상메모리는 fork()를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.

## 요구 페이징(Demand Paging)
프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라 하며, 가상 메모리 시스템에서 많이 사용된다. 그리고 가상 메모리는 대게 페이지로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다. 한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.

프로세스 내 개별 페이지들은 페이저(pager)에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리에 읽어 옴으로써, 사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄일 수 있다.

## 페이지 교체
요구 페이징에서 언급된대로 프로그램 실행 시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault(페이지 부재)가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. <br>
하지만, 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄줘야 한다. (또는 운영체제가 프로세스를 강제 종료하는 방법이 있다.)

### 기본적인 방법
물리 메모리가 모두 사용중이 상황에서의 메모리 교체 흐름이다.

1.디스크에서 필요한 페이지의 위치를 찾는다. <br>
2.빈 페이지 프레임을 찾는다. <br>
2-1.페이지 교체 알고리즘을 통해 희생될(victim)페이지를 고른다. <br>
2-2.희생될 페이지를 디스크에 기록하고, 관련된 테이블을 수정한다. <br>
3.새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다. <br>
4.사용자 프로세스 재시작 <br>

### 페이지 교체 알고리즘
1. FIFO(First in First out) - 가장 먼저 들어온 페이지를 교체 <br>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FU5nSm%2Fbtq9PUpYAl8%2FWtyueVDWhp6E2nLGbNHYWK%2Fimg.png" width="800"> <br>
가장 간단한 페이지 교체 알고리즘으로, FIFO의 흐름을 가진다. <br>
즉, 먼저 물리 메모리에 들어온 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.

- 장점 <br>
이해하기 쉽고, 프로그램하기도 쉽다.
- 단점 <br>
오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다. (초기 변수 등) <br>
처음부터 활발하게 사용되는 페이지를 교체해서 페이지 내 부재율을 높이는 부작용을 초래할 수 있다. <br>
Belady's Anomaly(FIFO anomaly): 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

2. OPT (Optimal) - 앞으로 가장 오랫동안 사용되지 않을 페이지 교체 <br>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FS8lUX%2Fbtq9JNyN39f%2FoYoWX91sjF34LkuFfuJxrk%2Fimg.png" width="800"> <br>
Belady의 모순을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 부재율을 보이며 Belady의 모순이 발생하지 않는다. 이 알고리즘의 핵심은 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 것이다. 주로 비교 연구 목적을 위해 사용한다.
- 장점 <br>
알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
- 단점 <br>
구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

3. LRU(Least Recently Used) - 가장 오랫동안 사용하지 않은 페이지를 교체 <br>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1csvE%2Fbtq9IZlYnx0%2FwbSZzZfsBkbmQ80nnf9LdK%2Fimg.png" width="800"> <br>
최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다. (가장 오랫동안 사용하지 않았던 데이터라면 앞으로도 사용할 확률이 적을 것이다.) <br>
대체적으로 FIFO 알고리즘보다 우수하고, OPT(최적) 알고리즘보다는 그렇지 못한 모습을 보인다.
- 단점 <br>
프로세스가 주기억장치에 접근할때마다 참조된 페이지 시간을 기록해야 하므로 막대한 오버헤드가 발생 <br>
카운터나 큐, 스택과 같은 별도의 하드웨어가 필요

4. LFU(Least Frequently Used) - 참조 횟수가 가장 낮은 페이지를 교체
LFU: Least Frequently Used
페이지의 참조 횟수로 교체할 페이지 결정하는 방법 
활발하게 사용되는 페이지는 참조 횟수가 많아질 것이라는 가정에서 만들어진 알고리즘이다.
- 단점 <br>
가장 최근에 불러온 페이지가 교체될 수 있고 구현이 복잡하며 막대한 오버헤드가 발생한다.

5. MFU(Most Frequently used) - 참조 횟수가 가장 많은 페이지 교체
참조 횟수가 가장 적은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.

<img src="" width="800"> <br>


> 참고사이트 : 
> - https://velog.io/@deannn/CS-%EA%B8%B0%EC%B4%88-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5
> - https://velog.io/@highgrace/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5

